"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[7820],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={title:"Ruby",id:"19-data-driven-testing-ruby",slug:"ruby/",number:19,publish_date:new Date("2015-07-14T00:00:00.000Z"),last_update:{date:new Date("2023-02-28T00:00:00.000Z")},tags:["data-driven testing","csv","authentication"],level:2,category:["remote"],language:"ruby"},o="How to Create a Data-driven Test",s={unversionedId:"updated-tips/data-driven-testing/19-data-driven-testing-ruby",id:"updated-tips/data-driven-testing/19-data-driven-testing-ruby",title:"Ruby",description:"Intro",source:"@site/docs/updated-tips/19-data-driven-testing/ruby.md",sourceDirName:"updated-tips/19-data-driven-testing",slug:"/updated-tips/data-driven-testing/ruby/",permalink:"/elemental-next/docs/updated-tips/data-driven-testing/ruby/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/updated-tips/19-data-driven-testing/ruby.md",tags:[{label:"data-driven testing",permalink:"/elemental-next/docs/tags/data-driven-testing"},{label:"csv",permalink:"/elemental-next/docs/tags/csv"},{label:"authentication",permalink:"/elemental-next/docs/tags/authentication"}],version:"current",frontMatter:{title:"Ruby",id:"19-data-driven-testing-ruby",slug:"ruby/",number:19,publish_date:"2015-07-14T00:00:00.000Z",last_update:{date:"2023-02-28T00:00:00.000Z"},tags:["data-driven testing","csv","authentication"],level:2,category:["remote"],language:"ruby"},sidebar:"tutorialSidebar",previous:{title:"What to Test",permalink:"/elemental-next/docs/updated-tips/how-to-figure-out-what-to-update/18-what-to-test"},next:{title:"Choosing a Programming Language",permalink:"/elemental-next/docs/updated-tips/adding-a-language/21-choosing-a-language"}},l={},u=[{value:"Intro",id:"intro",level:2},{value:"A Solution",id:"a-solution",level:2},{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2},{value:"About The Author",id:"about-the-author",level:2}],d={toc:u},p="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-to-create-a-data-driven-test"},"How to Create a Data-driven Test"),(0,r.kt)("h2",{id:"intro"},"Intro"),(0,r.kt)("p",null,"There are times when you run across functionality you want to test repeatedly with various inputs to see how the system behaves. We're going to go over a way to do this that will take some of the burden out of the process."),(0,r.kt)("p",null,"Sometimes performing these tests are because you want to test the expected outcomes. Other times, because you want to see if the system breaks in an odd way. But, wiring up all of these permutations into a set of automated tests can be burdensome and rife with copied code, which can make it hard to maintain over time."),(0,r.kt)("h2",{id:"a-solution"},"A Solution"),(0,r.kt)("p",null,"Enter Data-driven Testing."),(0,r.kt)("p",null,"By storing your desired inputs and expected outcomes in a central repository of some kind (e.g. a comma separated file, database, etc) you can easily wire up tests to use each of them instead of writing numerous tests and hard-coding these values directly in your test code."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"Let's start with an example -- testing a login form on a website (e.g., with ",(0,r.kt)("a",{parentName:"p",href:"http://the-internet.herokuapp.com/login"},"this example")," on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tourdedave/the-internet"},"the-internet"),")."),(0,r.kt)("p",null,"First, we are going to create a file to store the test inputs and expected outputs in. In this case, a CSV (comma-separated value) file called ",(0,r.kt)("inlineCode",{parentName:"p"},"user_data.csv"),", like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"account_type,username,password,notification_message\nbad_password,tomsmith,badPassword,Your password is invalid!\nbad_username,badUsername,SuperSecretPassword!,Your username is invalid!\nstandard_user,tomsmith,SuperSecretPassword!,You logged into a secure area!\n")),(0,r.kt)("p",null,"Next let's create our test file, require our requisite libraries (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"selenium-webdriver")," to control the browser, ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec/expectations")," & ",(0,r.kt)("inlineCode",{parentName:"p"},"RSpec::Matchers")," for our assertion, and ",(0,r.kt)("inlineCode",{parentName:"p"},"csv")," to import the data from our CSV file) and add some simple ",(0,r.kt)("inlineCode",{parentName:"p"},"setup"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"teardown"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," methods."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"# filename: data_driven.rb\n\nrequire 'selenium-webdriver'\nrequire 'rspec/expectations'\nrequire 'csv'\ninclude RSpec::Matchers\n\ndef setup\n  @driver = Selenium::WebDriver.for :firefox\nend\n\ndef teardown\n  @driver.quit\nend\n\ndef run\n  setup\n  yield\n  teardown\nend\n")),(0,r.kt)("p",null,"Now let's wire up our CSV parsing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"def user_data\n  user_data = CSV.read Dir.pwd + '/user_data.csv'\n  descriptor = user_data.shift\n  descriptor = descriptor.map { |key| key.to_sym }\n  user_data.map { |user| Hash[ descriptor.zip(user) ] }\nend\n")),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"user_data")," we read the CSV file in and grab the first row in it with ",(0,r.kt)("inlineCode",{parentName:"p"},".shift"),". We store this row in a variable called ",(0,r.kt)("inlineCode",{parentName:"p"},"descriptor")," and convert each value into a symbol. We then iterate over the rest of the CSV data and create a Hash object for each row of user data. In each Hash we are binding the relevant descriptor to each piece of user data (through the use of ",(0,r.kt)("inlineCode",{parentName:"p"},".zip"),"). This enables us to reference each of the user values by looking them up in the Hash by their descriptor symbol."),(0,r.kt)("p",null,"Next we'll need a helper method that will responsibly obtain the notification text from the page. It will need to both wait for the text to appear and clean up the resulting text so it doesn't include any extraneous characters."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"def notification_text\n  wait = Selenium::WebDriver::Wait.new(timeout: 5)\n  wait.until { @driver.find_element(class: 'flash').displayed? }\n  @driver.find_element(class: 'flash').text.delete('^a-zA-z !.')\nend\n")),(0,r.kt)("p",null,"We use the stock Selenium Wait function (e.g., an explicit wait) to continuously perform an action until either the timeout is reached or the action is true (whichever comes first). We then use it to see if the notification text is displayed on the page. If it is, then we grab the text and clean it up with a regular expression that deletes non-letter characters while preserving ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," and ",(0,r.kt)("inlineCode",{parentName:"p"},".")," (which are expected in the output we're testing for)."),(0,r.kt)("p",null,"Now we're ready to wire up our test. In it we will iterate through each of the user entries in the CSV file and use their data to both complete a login action and verify the notification message."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"user_data.each do |user|\n  run do\n    @driver.get 'http://the-internet.herokuapp.com/login'\n    @driver.find_element(id: 'username').send_keys user[:username]\n    @driver.find_element(id: 'password').send_keys user[:password]\n    @driver.find_element(id: 'login').submit\n    begin\n      expect(notification_text).to eql user[:notification_message]\n    rescue Exception => error\n      puts error.message\n    end\n  end\nend\n")),(0,r.kt)("p",null,"We wrap the notification message assertion in a ",(0,r.kt)("inlineCode",{parentName:"p"},"rescue")," block so that when an exception occurs the test will continue on with the next piece of user data after outputting the failure message to the command prompt."),(0,r.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,r.kt)("p",null,"If you save this file and run it (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"ruby data_driven.rb")," from the command-line) the script will parse the CSV file and perform the following for each entry:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Open the browser"),(0,r.kt)("li",{parentName:"ul"},"Load the login page"),(0,r.kt)("li",{parentName:"ul"},"Submit the login form with user data"),(0,r.kt)("li",{parentName:"ul"},"Grab the notification message and assert it against the expected value"),(0,r.kt)("li",{parentName:"ul"},"Close the browser")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"By storing data in a central repository to use for your tests and using Data-driven testing, you can simplify running repeated tests with various outputs."),(0,r.kt)("p",null,"Happy Testing!"),(0,r.kt)("h2",{id:"about-the-author"},"About The Author"),(0,r.kt)("p",null,"Dave Haeffner is the original writer of Elemental Selenium -- a free, once weekly Selenium tip newsletter that's read by thousands of testing professionals. He also created and maintains the-internet (an open-source web app that's perfect for writing automated tests against)."),(0,r.kt)("p",null,"Dave has helped numerous companies successfully implement automated acceptance testing; including The Motley Fool, ManTech International, Sittercity, and Animoto. He is also an active member of the Selenium project and has spoken at numerous conferences and meetups around the world about automated acceptance testing."))}c.isMDXComponent=!0}}]);