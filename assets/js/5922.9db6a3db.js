"use strict";(self.webpackChunkelemental_selenium=self.webpackChunkelemental_selenium||[]).push([[5922],{65922:(e,n,r)=>{r.r(n),r.d(n,{contentTitle:()=>i,default:()=>d,frontMatter:()=>t,toc:()=>l});var s=r(74848),a=r(28453);const t={},i=void 0,l=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}];function o(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"Our initial setup stays mostly the same. There are only a couple of minor changes we'll need to make."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"ENV['SAUCE_USERNAME'] = 'your username'\nENV['SAUCE_API_KEY']  = 'your api key'\n\nrequire 'selenium-webdriver'\nrequire 'rspec/expectations'\n\ndef setup(browser_name, browser_version)\n  caps = Selenium::WebDriver::Remote::Capabilities.send(browser_name.to_sym)\n  caps.platform = 'Windows XP'\n  caps.version = browser_version.to_s\n\n  Thread.current[:driver] = Selenium::WebDriver.for(\n    :remote,\n    url: \"https://#{ENV['SAUCE_USERNAME']}:#{ENV['SAUCE_API_KEY']}@ondemand.saucelabs.com/wd/hub\",\n    desired_capabilities: caps)\nend\n\ndef teardown\n  Thread.current[:driver].quit\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"Since we are working with threads, we will need to use variables that are thread safe. The best candidates are\nthread local variables. They have a global scope (similar to global variables) but are only accessible from within\nthe thread that created it. This way we won't run into any odd collisions across simultaneous test runs."}),"\n",(0,s.jsxs)(n.p,{children:["So instead of instance variables (e.g., ",(0,s.jsx)(n.code,{children:"@driver"}),") we are now storing each instance of Selenium in this new kind of\nvariable and referencing it as needed (e.g., ",(0,s.jsx)(n.code,{children:"Thread.current[:driver]"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# filename: example42.rb\n\nBROWSERS = { firefox: '27',\n             chrome: '32',\n             internet_explorer: '8' }\n\ndef run\n  threads = []\n  BROWSERS.each_pair do |browser, browser_version|\n    threads << Thread.new do\n      setup(browser, browser_version)\n      yield\n      teardown\n    end\n  end\n  threads.each { |thread| thread.join }\nend\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Our browser list remains untouched, but our ",(0,s.jsx)(n.code,{children:"run"})," method has been updated to spawn and join threads (which is how\nyou finish a thread). With this setup a new thread will be spawned for each of the browsers in the list, perform\nits actions, and finish."]}),"\n",(0,s.jsx)(n.p,{children:"Will all of that in place, we just need to update our test to use the new thread local driver variable."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"run do\n  Thread.current[:driver].get 'https://the-internet.herokuapp.com'\n  Thread.current[:driver].title.should == 'The Internet'\nend\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we run this script from the command line (",(0,s.jsx)(n.code,{children:"ruby examle42.rb"}),") and head over\n",(0,s.jsx)(n.a,{href:"https://saucelabs.com/account",children:"the Sauce Labs Account page"}),", then we should see three tests running simultaneously."]}),"\n",(0,s.jsxs)(n.p,{children:["NOTE: the number of parallel sessions allotted to your Sauce Labs account will dictate how quickly your tests will\nfinish. For instance, if you add two new browsers to ",(0,s.jsx)(n.code,{children:"BROWSER_LIST"})," and run this, only 3 sessions will run in Sauce\nLabs, queuing the other two until some of the original sessions finish."]}),"\n",(0,s.jsx)(n.h2,{id:"expected-behavior",children:"Expected Behavior"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simultaneously loads each browser in a Sauce Labs job"}),"\n",(0,s.jsx)(n.li,{children:"Each test loads the page and asserts the title is correct"}),"\n",(0,s.jsx)(n.li,{children:"Each session closes when it is complete"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"There are alternative ways to run your tests in parallel. Some more notable approaches include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"through a test framework (e.g., TestNG in Java)"}),"\n",(0,s.jsx)(n.li,{children:"through Continuous Integration"}),"\n",(0,s.jsxs)(n.li,{children:["through a third-party library (e.g., ",(0,s.jsx)(n.a,{href:"https://github.com/grosser/parallel_tests",children:"parallel_tests in Ruby"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For a full write-up on how to parallel_tests, check out ",(0,s.jsx)(n.a,{href:"https://elementalselenium.com/docs/parallel/27-parallel",children:"tip 27"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Happy Testing!"})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);