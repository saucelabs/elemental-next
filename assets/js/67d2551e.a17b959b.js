"use strict";(self.webpackChunkelemental_selenium=self.webpackChunkelemental_selenium||[]).push([[25536,71841],{71841:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=n(74848),i=n(28453);const s={},a=void 0,o={id:"data-driven-testing/_ruby",title:"_ruby",description:"Example",source:"@site/tips/19-data-driven-testing/_ruby.mdx",sourceDirName:"19-data-driven-testing",slug:"/data-driven-testing/_ruby",permalink:"/tips/data-driven-testing/_ruby",draft:!1,unlisted:!1,editUrl:"https://github.com/saucelabs/elemental-next/blob/main/frontend/tips/19-data-driven-testing/_ruby.mdx",tags:[],version:"current",lastUpdatedBy:"renovate[bot]",lastUpdatedAt:172223951e4,frontMatter:{},sidebar:"defaultSidebar",previous:{title:"How To Figure Out What to Test",permalink:"/tips/18-what-to-test"},next:{title:"Data Driven Testing",permalink:"/tips/19-data-driven-testing"}},d={},l=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(t.p,{children:["Let's start with an example -- testing a login form on a website (e.g., with ",(0,r.jsx)(t.a,{href:"http://the-internet.herokuapp.com/login",children:"this example"})," on ",(0,r.jsx)(t.a,{href:"https://github.com/saucelabs/the-internet",children:"the-internet"}),")."]}),"\n",(0,r.jsxs)(t.p,{children:["First, we are going to create a file to store the test inputs and expected outputs in. In this case, a CSV (comma-separated value) file called ",(0,r.jsx)(t.code,{children:"user_data.csv"}),", like so:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-text",children:"account_type,username,password,notification_message\nbad_password,tomsmith,badPassword,Your password is invalid!\nbad_username,badUsername,SuperSecretPassword!,Your username is invalid!\nstandard_user,tomsmith,SuperSecretPassword!,You logged into a secure area!\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Next let's create our test file, require our requisite libraries (e.g., ",(0,r.jsx)(t.code,{children:"selenium-webdriver"})," to control the browser, ",(0,r.jsx)(t.code,{children:"rspec/expectations"})," & ",(0,r.jsx)(t.code,{children:"RSpec::Matchers"})," for our assertion, and ",(0,r.jsx)(t.code,{children:"csv"})," to import the data from our CSV file) and add some simple ",(0,r.jsx)(t.code,{children:"setup"}),", ",(0,r.jsx)(t.code,{children:"teardown"}),", and ",(0,r.jsx)(t.code,{children:"run"})," methods."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:"# filename: data_driven.rb\n\nrequire 'selenium-webdriver'\nrequire 'rspec/expectations'\nrequire 'csv'\ninclude RSpec::Matchers\n\ndef setup\n  @driver = Selenium::WebDriver.for :firefox\nend\n\ndef teardown\n  @driver.quit\nend\n\ndef run\n  setup\n  yield\n  teardown\nend\n"})}),"\n",(0,r.jsx)(t.p,{children:"Now let's wire up our CSV parsing."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:"def user_data\n  user_data = CSV.read Dir.pwd + '/user_data.csv'\n  descriptor = user_data.shift\n  descriptor = descriptor.map { |key| key.to_sym }\n  user_data.map { |user| Hash[ descriptor.zip(user) ] }\nend\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In ",(0,r.jsx)(t.code,{children:"user_data"})," we read the CSV file in and grab the first row in it with ",(0,r.jsx)(t.code,{children:".shift"}),". We store this row in a variable called ",(0,r.jsx)(t.code,{children:"descriptor"})," and convert each value into a symbol. We then iterate over the rest of the CSV data and create a Hash object for each row of user data. In each Hash we are binding the relevant descriptor to each piece of user data (through the use of ",(0,r.jsx)(t.code,{children:".zip"}),"). This enables us to reference each of the user values by looking them up in the Hash by their descriptor symbol."]}),"\n",(0,r.jsx)(t.p,{children:"Next we'll need a helper method that will responsibly obtain the notification text from the page. It will need to both wait for the text to appear and clean up the resulting text, so it doesn't include any extraneous characters."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:"def notification_text\n  wait = Selenium::WebDriver::Wait.new(timeout: 5)\n  wait.until { @driver.find_element(class: 'flash').displayed? }\n  @driver.find_element(class: 'flash').text.delete('^a-zA-z !.')\nend\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We use the stock Selenium Wait function (e.g., an explicit wait) to continuously perform an action until either the timeout is reached or the action is true (whichever comes first). We then use it to see if the notification text is displayed on the page. If it is, then we grab the text and clean it up with a regular expression that deletes non-letter characters while preserving ",(0,r.jsx)(t.code,{children:"!"})," and ",(0,r.jsx)(t.code,{children:"."})," (which are expected in the output we're testing for)."]}),"\n",(0,r.jsx)(t.p,{children:"Now we're ready to wire up our test. In it, we will iterate through each of the user entries in the CSV file and use their data to both complete a login action and verify the notification message."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:"user_data.each do |user|\n  run do\n    @driver.get 'http://the-internet.herokuapp.com/login'\n    @driver.find_element(id: 'username').send_keys user[:username]\n    @driver.find_element(id: 'password').send_keys user[:password]\n    @driver.find_element(id: 'login').submit\n    begin\n      expect(notification_text).to eql user[:notification_message]\n    rescue Exception => error\n      puts error.message\n    end\n  end\nend\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We wrap the notification message assertion in a ",(0,r.jsx)(t.code,{children:"rescue"})," block so that when an exception occurs the test will continue on with the next piece of user data after outputting the failure message to the command prompt."]}),"\n",(0,r.jsx)(t.h2,{id:"expected-behavior",children:"Expected Behavior"}),"\n",(0,r.jsxs)(t.p,{children:["If you save this file and run it (e.g., ",(0,r.jsx)(t.code,{children:"ruby data_driven.rb"})," from the command-line) the script will parse the CSV file and perform the following for each entry:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Open the browser"}),"\n",(0,r.jsx)(t.li,{children:"Load the login page"}),"\n",(0,r.jsx)(t.li,{children:"Submit the login form with user data"}),"\n",(0,r.jsx)(t.li,{children:"Grab the notification message and assert it against the expected value"}),"\n",(0,r.jsx)(t.li,{children:"Close the browser"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.p,{children:"By storing data in a central repository to use for your tests and using Data-driven testing, you can simplify running repeated tests with various outputs."}),"\n",(0,r.jsx)(t.p,{children:"Happy Testing!"})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(96540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);