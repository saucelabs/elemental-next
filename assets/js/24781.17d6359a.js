"use strict";(self.webpackChunkelemental_selenium=self.webpackChunkelemental_selenium||[]).push([[24781],{24781:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var n=i(74848),s=i(28453);const r={},a=void 0,o={id:"waiting/_ruby",title:"_ruby",description:"Example",source:"@site/tips/47-waiting/_ruby.mdx",sourceDirName:"47-waiting",slug:"/waiting/_ruby",permalink:"/tips/waiting/_ruby",draft:!1,unlisted:!1,editUrl:"https://github.com/saucelabs/elemental-next/blob/main/frontend/tips/47-waiting/_ruby.mdx",tags:[],version:"current",lastUpdatedBy:"renovate[bot]",lastUpdatedAt:1723676051e3,frontMatter:{},sidebar:"defaultSidebar",previous:{title:"How To Test Checkboxes",permalink:"/tips/45-checkboxes"},next:{title:"Implicit vs Explicit Waits",permalink:"/tips/47-waiting"}},l={},d=[{value:"Example",id:"example",level:2},{value:"On Not Mixing Explicit and Implicit WaitsIf your test suite uses both explicit and implicit waits, then you&#39;re in for some pain (e.g., transient failures as you scale your test suite). For more details about this, check out this StackOverflow answer from Jim Evans (a member of the Selenium core team).The best thing is to only use explicit waits. We already have them in place, so we can go ahead and simply remove the implicit wait from our <code>setup</code> method.```rubydef setup  @driver = Selenium::WebDriver.for ",id:"on-not-mixing-explicit-and-implicit-waitsif-your-test-suite-uses-both-explicit-and-implicit-waits-then-youre-in-for-some-pain-eg-transient-failures-as-you-scale-your-test-suite-for-more-details-about-this-check-out-this-stackoverflow-answer-from-jim-evans-a-member-of-the-selenium-core-teamthe-best-thing-is-to-only-use-explicit-waits-we-already-have-them-in-place-so-we-can-go-ahead-and-simply-remove-the-implicit-wait-from-our-setup-methodrubydef-setup--driver--seleniumwebdriverfor-",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,n.jsxs)(t.p,{children:["Let's step through some examples that deal with ",(0,n.jsx)(t.a,{href:"http://the-internet.herokuapp.com/dynamic_loading",children:"dynamically loaded content"})," available on ",(0,n.jsx)(t.a,{href:"https://github.com/saucelabs/the-internet",children:"the-internet"}),". There are two examples, each is constructed slightly differently, but they have the same behavior (e.g., when you click the button on the page a loading bar appears for 5 seconds then disappears and displays some text)."]}),"\n",(0,n.jsxs)(t.p,{children:["First let's pull in our dependent libraries (e.g., ",(0,n.jsx)(t.code,{children:"selenium-webdriver"})," to drive the browser, and ",(0,n.jsx)(t.code,{children:"rspec/expectations"})," and ",(0,n.jsx)(t.code,{children:"RSpec::Matchers"})," for our assertions) and wire up some simple methods (e.g., ",(0,n.jsx)(t.code,{children:"setup"}),", ",(0,n.jsx)(t.code,{children:"teardown"}),", and ",(0,n.jsx)(t.code,{children:"run"}),") to handle our test configuration."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ruby",children:"# filename: waiting.rb\n\nrequire 'selenium-webdriver'\nrequire 'rspec/expectations'\ninclude RSpec::Matchers\n\ndef setup\n  @driver = Selenium::WebDriver.for :firefox\n  @driver.manage.timeouts.implicit_wait = 3\nend\n\ndef teardown\n  @driver.quit\nend\n\ndef run\n  setup\n  yield\n  teardown\nend\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Notice that in ",(0,n.jsx)(t.code,{children:"setup"})," we are specifying an implicit wait of ",(0,n.jsx)(t.code,{children:"3"})," seconds. This tells Selenium to retry each ",(0,n.jsx)(t.code,{children:"find_element"})," action for up to 3 seconds. If it can complete the action in that amount of time, it will proceed onto the next command. Otherwise, it will raise a timeout exception."]}),"\n",(0,n.jsx)(t.p,{children:"Now let's add our first test."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ruby",children:"run do\n  @driver.get 'http://the-internet.herokuapp.com/dynamic_loading/1'\n  @driver.find_element(css: '#start button').click\n  @driver.find_element(id: 'finish').displayed?\n  expect(@driver.find_element(id: 'finish').text).to eql('Hello World!')\nend\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this example the element we're interested in is already on the page, just hidden. When we execute this (e.g., ",(0,n.jsx)(t.code,{children:"ruby waiting.rb"})," from the command-line) the ",(0,n.jsx)(t.code,{children:".displayed?"})," step runs, but it doesn't trigger the implicit wait. Instead, the test proceeds directly to the assertion looking for text that's not there and failing."]}),"\n",(0,n.jsx)(t.p,{children:"Let's run the same test against the other dynamic loading example."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ruby",children:"run do\n  @driver.get 'http://the-internet.herokuapp.com/dynamic_loading/2'\n  @driver.find_element(css: '#start button').click\n  @driver.find_element(id: 'finish').displayed?\n  expect(@driver.find_element(id: 'finish').text).to eql('Hello World!')\nend\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this example the element we're interested in gets rendered ",(0,n.jsx)(t.em,{children:"after"})," the loading bar. When we run this (e.g., ",(0,n.jsx)(t.code,{children:"ruby waiting.rb"})," from the command-line) the ",(0,n.jsx)(t.code,{children:".displayed?"})," step will wait as we intend, but the assertion will still fail. That's because the implicit wait is not long enough (because the loading bar takes 5 seconds to complete, but the implicit wait is set at ",(0,n.jsx)(t.code,{children:"3"})," seconds)."]}),"\n",(0,n.jsxs)(t.p,{children:["Now we're at a cross-roads. Do we increase the implicit wait to account for this? That would be a simple enough fix for this example. But that's a bad option since it would impact ",(0,n.jsx)(t.em,{children:"all"})," tests that use this setup. Instead, we can use an explicit wait."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ruby",children:"def wait_for(seconds)\n  Selenium::WebDriver::Wait.new(timeout: seconds).until { yield }\nend\n\nrun do\n  @driver.get 'http://the-internet.herokuapp.com/dynamic_loading/2'\n  @driver.find_element(css: '#start button').click\n  wait_for(10) { @driver.find_element(id: 'finish').displayed? }\n  expect(@driver.find_element(id: 'finish').text).to eql('Hello World!')\nend\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If we wrap our ",(0,n.jsx)(t.code,{children:".displayed?"})," action in an explicit wait we are able to override the implicit wait and wait for up 10 seconds. Now when we run our test, our test will pass. And if we revisit our first example and do the same, then it will pass too."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ruby",children:"run do\n  @driver.get 'http://the-internet.herokuapp.com/dynamic_loading/1'\n  @driver.find_element(css: '#start button').click\n  wait_for(10) { @driver.find_element(id: 'finish').displayed? }\n  expect(@driver.find_element(id: 'finish').text).to eql('Hello World!')\nend\n"})}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.h3,{id:"on-not-mixing-explicit-and-implicit-waitsif-your-test-suite-uses-both-explicit-and-implicit-waits-then-youre-in-for-some-pain-eg-transient-failures-as-you-scale-your-test-suite-for-more-details-about-this-check-out-this-stackoverflow-answer-from-jim-evans-a-member-of-the-selenium-core-teamthe-best-thing-is-to-only-use-explicit-waits-we-already-have-them-in-place-so-we-can-go-ahead-and-simply-remove-the-implicit-wait-from-our-setup-methodrubydef-setup--driver--seleniumwebdriverfor-",children:["On Not Mixing Explicit and Implicit WaitsIf your test suite uses both explicit and implicit waits, then you're in for some pain (e.g., transient failures as you scale your test suite). For more details about this, check out ",(0,n.jsx)(t.a,{href:"http://stackoverflow.com/questions/15164742/combining-implicit-wait-and-explicit-wait-together-results-in-unexpected-wait-ti#answer-15174978",children:"this StackOverflow answer"})," from ",(0,n.jsx)(t.a,{href:"https://twitter.com/jimevansmusic",children:"Jim Evans"})," (a member of the Selenium core team).The best thing is to only use explicit waits. We already have them in place, so we can go ahead and simply remove the implicit wait from our ",(0,n.jsx)(t.code,{children:"setup"})," method.```rubydef setup  @driver = Selenium::WebDriver.for ",":firefoxend"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-And",metastring:"there you go!## Expected Behavior"})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["If we save the file and run it (e.g., ",(0,n.jsx)(t.code,{children:"ruby waiting.rb"})," from the command-line) here is what will happen:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Open the browser"}),"\n",(0,n.jsx)(t.li,{children:"Visit the page"}),"\n",(0,n.jsx)(t.li,{children:"Click the Start button"}),"\n",(0,n.jsx)(t.li,{children:"Wait for the progress bar to disappear and finish text to appear"}),"\n",(0,n.jsx)(t.li,{children:"Assert that the finish text appears on the page"}),"\n",(0,n.jsx)(t.li,{children:"Close the browser"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsx)(t.p,{children:"While an implicit wait can be useful, providing you an initial blanket of cover, it's not ideal for every circumstance. Instead, explicit waits are a better tool for the job since they provide more resilient and predictable results (even if they make your test code more verbose)."}),"\n",(0,n.jsx)(t.p,{children:"Regardless of the approach you choose, be sure never to mix implicit and explicit waits together."}),"\n",(0,n.jsx)(t.p,{children:"Happy Testing!"})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);