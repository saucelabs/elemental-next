"use strict";(self.webpackChunkelemental_selenium=self.webpackChunkelemental_selenium||[]).push([[686],{20686:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>r,default:()=>d,frontMatter:()=>a,toc:()=>o});var s=t(74848),i=t(28453);const a={},r=void 0,o=[{value:"Example",id:"example",level:2},{value:"Going beyond signups",id:"going-beyond-signups",level:2},{value:"Testing against REST only",id:"testing-against-rest-only",level:2},{value:"Summary",id:"summary",level:2},{value:"About The Author",id:"about-the-author",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:'I decided to pick an example that is nearly ubiquitous: sign-up. When we make a new user for a test, we have a "clean slate" which allows us great control over how to shape that user for our test. We eliminate possible corruption of our test user\'s state from other tests. And if we make that user using a REST API call, we avoid the time penalty of having to fill out a sign-up form (not to mention having to find any emails involved in confirming an email address).'}),"\n",(0,s.jsx)(n.p,{children:"Suppose our hypothetical website is backed by a REST API, and it documents a call to create a user as follows:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"POST http://api.myfakeapp.com/v1/create-user"})}),"\n",(0,s.jsx)(n.p,{children:"This call takes a JSON request body, and creates a user."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"{\n  'username':   'example-username',\n  'password':   'abcd1234',\n  'email':      'bob@example.com',\n  'first_name': 'bob',\n  'last_name':  'example'\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["That tells us we will have to send an ",(0,s.jsx)(n.code,{children:"HTTP POST"})," request to the URL ",(0,s.jsx)(n.code,{children:"/v1/create-user"}),", with a JSON object body that has valid values for all of the fields shown. If this all sounds scary, it might help to know that this is more-or-less what your browser does when you submit a form. In this case though, we are going to do it sans-browser."]}),"\n",(0,s.jsxs)(n.p,{children:["The following module has a ",(0,s.jsx)(n.code,{children:"create_test_user"})," method which we will incorporate into our test setups. It contains some helpful inline comments that describe each of the actions being taken."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# filename: rest_api_interface.rb\n\nrequire 'net/http'\nrequire 'json'\nrequire 'securerandom'\n\nmodule RestApiInterface\n\n  Headers = {\n    'content-type' => 'application/json',\n    'user-agent' => 'Rest Api Helper',\n  }\n\n  def post_to_api path, post_body_obj\n    json_body = JSON.generate(post_body_obj)\n    response = nil\n    Net::HTTP.start('api.myfakeapp.com') do |http|\n      response = http.post(path, json_body, Headers)\n    end\n    response\n  end\n\n  def create_test_user\n    # Step 1: Build the user parameters randomly\n    random_test_user = {\n      'username'   => random_string,\n      'password'   => random_string,\n      'email'      => \"#{random_string}@testing.com\",\n      'first_name' => 'test',\n      'last_name'  => 'user',\n    }\n\n    # Step 2: Execute the API call\n    response = post_to_api '/v0/oauth/create-profile', random_test_user\n\n    # Step 3: Ensure the api call returned a success code\n    if response.code != '200'\n      raise 'User creation failed'\n    end\n\n    # Final Step: Return the user object so we can use it\n    random_test_user\n  end\n\n  def random_string\n    # This is an easy way to get a good randomized string\n    SecureRandom.hex\n  end\nend\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"With this we are now ready to make, and then use, test users from within our Selenium code."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"require 'selenium-webdriver'\nrequire 'rest_api_interface'\ninclude RestApiInterface\n\ndef setup\n  @driver = Selenium::WebDriver.for :firefox\n  @user = create_test_user\nend\n\ndef login\n  @driver.get 'http://myfakeapp.com'\n  @driver.find_element(:css, 'input[name=\"username\"]').send_keys @user['username']\n  @driver.find_element(:css, 'input[name=\"password\"]').send_keys @user['password']\n  @driver.find_element(:css, 'button[name=\"login\"]').click\nend\n\ndef teardown\n  @driver.quit\nend\n\ndef run\n  setup\n  login\n  yield\n  teardown\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"With support code like the above, we are free to write code that can assume we are logged in with a clean user. Like the following (which will output the user that is logged in)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"run do\n  puts @driver.find_element(:css, '#user_id').text\nend\n"})}),"\n",(0,s.jsx)(n.h2,{id:"going-beyond-signups",children:"Going beyond signups"}),"\n",(0,s.jsx)(n.p,{children:"This technique of mixing in REST API calls with your Selenium code is very powerful. Admittedly, the example given is easy to criticize. Signing up a fresh user for every test is probably not an appropriate strategy for many sites. Further, the example does not get around having to login. Once the mechanics of this kind of interaction are in place however, it becomes possible to setup many kind of resources and relationships between them using REST API calls."}),"\n",(0,s.jsx)(n.p,{children:"I used to work for an organization that ran highly specialized markets, with several configuration options, as well as different kinds of users including buyers and sellers. I used this technique to build test markets through all permutations of configuration with test buyers and sellers. My Selenium tests would then simply visit the test markets as the test buyers and sellers and confirm the expected features were available.This allowed my tests to provide both a high level of coverage while staying fast, precise, and wholly self-contained."}),"\n",(0,s.jsx)(n.h2,{id:"testing-against-rest-only",children:"Testing against REST only"}),"\n",(0,s.jsx)(n.p,{children:'Once you\'ve gotten used to using REST APIs to create test data fast, there is a question that naturally pops up: "Why not just test against the REST API itself, without using Selenium?"'}),"\n",(0,s.jsx)(n.p,{children:"Indeed, there are many great reasons to consider pure REST API tests to supplement a Selenium test suite. When compared to Selenium tests, pure REST API tests are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Extremely fast"}),"\n",(0,s.jsx)(n.li,{children:"Extremely reliable"}),"\n",(0,s.jsx)(n.li,{children:"Easier to build higher levels of test coverage"}),"\n",(0,s.jsx)(n.li,{children:"Simpler execution architecture."}),"\n",(0,s.jsx)(n.li,{children:"More encouraging of testable design in the application"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"REST API tests are very appropriate for exercising the business logic that powers an application. Of course they leave a lot of important parts of the application untested including Javascript within the website, thus they should never be considered a complete Selenium replacement."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Note: Given the ever increasing important of mobile applications, I believe special mention concerning the testing of a mobile application is important here. There are several Selenium like tools for mobile testing out there, but the landscape is still quite immature. Fortunately, the majority of most mobile applications are in fact backed by a REST API. Pure REST API testing should be considered an important component of any test plan for every mobile application!"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"When considering how to make your Selenium suite have higher coverage, run faster, and be more reliable, it is often worth looking beyond Selenium for solutions to these common problems. REST APIs are becoming very common and provide a relatively easy means for creating test data which Selenium tests can make use of. REST APIs can in fact be a powerful way to test an application all by themselves."}),"\n",(0,s.jsx)(n.h2,{id:"about-the-author",children:"About The Author"}),"\n",(0,s.jsxs)(n.p,{children:["Robert Schultheis is a Test Engineer for ",(0,s.jsx)(n.a,{href:"http://www.knewton.com/",children:"Knewton"}),", a company devoted to personalizing education for every student globally.  He gave ",(0,s.jsx)(n.a,{href:"http://www.youtube.com/watch?v=WIMF7Nc1sbY",children:"a talk"})," with more details about using REST APIs for testing and beyond, and has also released a Ruby gem known as ",(0,s.jsx)(n.a,{href:"https://github.com/Knewton/grifter",children:"Grifter"})," which allows for the creation of DSLs for interacting with REST APIs easily."]}),"\n",(0,s.jsx)(n.p,{children:'Robert wishes to express his gratitude to Dave for allowing him a chance to author this guest post, and wishes "Happy Testing" to all Elemental Selenium readers.'})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);