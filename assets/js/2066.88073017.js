"use strict";(self.webpackChunkelemental_selenium=self.webpackChunkelemental_selenium||[]).push([[2066],{22066:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>r,default:()=>c,frontMatter:()=>a,toc:()=>o});var i=t(74848),s=t(28453);const a={},r=void 0,o=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["The example application is a page that displays a notification message at the top of the page. It will either say ",(0,i.jsx)(n.strong,{children:"Action successful"})," or ",(0,i.jsx)(n.strong,{children:"Action unsuccessful, please try again"}),". You can see it ",(0,i.jsx)(n.a,{href:"http://the-internet.herokuapp.com/notification_message",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Our goal in this example is verify an ",(0,i.jsx)(n.strong,{children:"Action successful"})," message."]}),"\n",(0,i.jsx)(n.p,{children:"The beginning of our test script starts off simply with accessing our libraries (Selenium and RSpec) and creating our setup, teardown, and run actions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"require 'selenium-webdriver'\nrequire 'rspec/expectations'\n\ndef setup\n  @driver = Selenium::WebDriver.for :firefox\nend\n\ndef teardown\n  @driver.quit\nend\n\ndef run\n  setup\n  yield\n  teardown\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"A first pass at this example would look something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"run {\n  @driver.get 'http://the-internet.herokuapp.com/notification_message'\n  notification_message = @driver.find_element(id: 'flash').text\n  notification_message =~ /Action successful/\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The problem with this approach is that it will fail intermittently because the page's notification message could very well be something else. But the next time you load it, it could be the correct thing."}),"\n",(0,i.jsx)(n.p,{children:"Perhaps something like this would be better suited:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"def get_notification_message\n  @notification_message = @driver.find_element(id: 'flash').text\nend\n\ndef retry_if_notification_message_contains(fail_message)\n  count = 0\n  yield\n  until !@notification_message.include? fail_message || count == 3\n    yield\n    count =+ 1\n  end\nend\n\nrun {\n  retry_if_notification_message_contains 'please try again' do\n    @driver.get 'http://the-internet.herokuapp.com/notification_message'\n    get_notification_message\n  end\n  @notification_message =~ /Action successful/\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this approach we have abstracted out the text grab of the notification message into a method which sets what it finds into an instance variable. And we've added a new method called ",(0,i.jsx)(n.code,{children:"retry_if_notification_message_contains"})," that accepts an argument of ",(0,i.jsx)(n.code,{children:"fail_message"}),". In it, we accept a yield in 2 places and have constructed a simple loop that runs 3 times or until the notification message does not match the ",(0,i.jsx)(n.code,{children:"fail_message"}),", whichever comes first. And the yields will execute whatever code is passed both before and during the loop."]}),"\n",(0,i.jsxs)(n.p,{children:["In the run block we pass our navigation and text grab actions as a block into ",(0,i.jsx)(n.code,{children:"retry_if_notification_message_contains"}),", passing the failure message of ",(0,i.jsx)(n.strong,{children:"please try again"})," as the argument for ",(0,i.jsx)(n.code,{children:"fail_message"})," to receive."]}),"\n",(0,i.jsx)(n.p,{children:"And we top everything off with an assertion."}),"\n",(0,i.jsx)(n.h2,{id:"expected-behavior",children:"Expected Behavior"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Load the page"}),"\n",(0,i.jsx)(n.li,{children:"Grab the notification message text"}),"\n",(0,i.jsx)(n.li,{children:"Compare it to the failure message"}),"\n",(0,i.jsx)(n.li,{children:"If it matches, retry"}),"\n",(0,i.jsx)(n.li,{children:"If 3 retries attempted, end loop, and fail test"}),"\n",(0,i.jsx)(n.li,{children:"If it doesn't match, pass the test"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"With this approach there may be a concern that we could be obfuscating a real issue that could bubble up to our users. That's why it is important to use this approach sparingly, and on issues you more or less understand (e.g. a third-party test environment having one-off service blips, or expensive tests that involve sharing something to a third-party and checking to see that it appeared)."}),"\n",(0,i.jsx)(n.p,{children:"Hopefully this example will help you build a more resilient and relevant set of tests."}),"\n",(0,i.jsx)(n.p,{children:"Happy Testing!"})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);