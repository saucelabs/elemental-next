"use strict";(self.webpackChunkelemental_selenium=self.webpackChunkelemental_selenium||[]).push([[59764,33150],{33150:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var n=t(74848),s=t(28453);const o={},i=void 0,a={id:"retrieve-http-status-codes/_ruby",title:"_ruby",description:"A Solution",source:"@site/tips/17-retrieve-http-status-codes/_ruby.mdx",sourceDirName:"17-retrieve-http-status-codes",slug:"/retrieve-http-status-codes/_ruby",permalink:"/tips/retrieve-http-status-codes/_ruby",draft:!1,unlisted:!1,editUrl:"https://github.com/saucelabs/elemental-next/blob/main/frontend/tips/17-retrieve-http-status-codes/_ruby.mdx",tags:[],version:"current",lastUpdatedBy:"renovate[bot]",lastUpdatedAt:1725691078e3,frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Take Screenshot on Failure",permalink:"/tips/16-take-screenshot-on-failure"},next:{title:"Retrieve HTTP Status Codes",permalink:"/tips/17-retrieve-http-status-codes"}},l={},c=[{value:"A Solution",id:"a-solution",level:2},{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const r={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h2,{id:"a-solution",children:"A Solution"}),"\n",(0,n.jsx)(r.p,{children:"The tried and true approach that Selenium Committers and Practitioners recommend is to use a proxy server. With it, you will be able to watch and manipulate network traffic to and from the application you're testing. Thus giving you access to a whole host of functionality that isn't available otherwise."}),"\n",(0,n.jsxs)(r.p,{children:["Let's step through an example using ",(0,n.jsx)(r.a,{href:"http://bmp.lightbody.net/",children:"BrowserMob Proxy"}),"."]}),"\n",(0,n.jsx)(r.h2,{id:"example",children:"Example"}),"\n",(0,n.jsxs)(r.p,{children:["First we need to download a copy of ",(0,n.jsx)(r.a,{href:"http://bmp.lightbody.net/",children:"BrowserMob Proxy"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["Next we'll create a script and pull in our requisite libraries (e.g., ",(0,n.jsx)(r.code,{children:"selenium-webdriver"})," to drive the browser, ",(0,n.jsx)(r.code,{children:"rspec/expectations"})," and it's matchers for our assertion, and the ",(0,n.jsx)(r.a,{href:"https://github.com/jarib/browsermob-proxy-rb",children:(0,n.jsx)(r.code,{children:"browsermob/proxy"})})," library to control the proxy server)."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ruby",children:"# filename: status_codes.rb\n\nrequire 'selenium-webdriver'\nrequire 'rspec/expectations'\ninclude RSpec::Matchers\nrequire 'browsermob/proxy'\n"})}),"\n",(0,n.jsx)(r.p,{children:"Now let's create a method to prepare the proxy for use with Selenium. In it, we start the proxy server, configure a browser profile to use it (for Firefox in this case), and return the profile object."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ruby",children:"def configure_proxy\n  server = BrowserMob::Proxy::Server.new(\n    File.join(Dir.pwd, 'browsermob-proxy-2.0.0/bin/browsermob-proxy'))\n  @proxy = server.start.create_proxy\n  profile = Selenium::WebDriver::Firefox::Profile.new\n  profile.proxy = @proxy.selenium_proxy\n  profile\nend\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Next we wire up some simple ",(0,n.jsx)(r.code,{children:"setup"}),", ",(0,n.jsx)(r.code,{children:"teardown"}),", and ",(0,n.jsx)(r.code,{children:"run"})," methods to handle our test configuration."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ruby",children:"def setup\n  @driver = Selenium::WebDriver.for :firefox, profile: configure_proxy\nend\n\ndef teardown\n  @driver.quit\n  @proxy.close\nend\n\ndef run\n  setup\n  yield\n  teardown\nend\n"})}),"\n",(0,n.jsxs)(r.p,{children:["In ",(0,n.jsx)(r.code,{children:"setup"})," we use the ",(0,n.jsx)(r.code,{children:"configure_proxy"})," method when specifying the profile object. And we close the proxy in ",(0,n.jsx)(r.code,{children:"teardown"})," (after quitting the Selenium session)."]}),"\n",(0,n.jsxs)(r.p,{children:["Now let's create a helper method to pull the status code out of the browser's ",(0,n.jsx)(r.a,{href:"http://www.softwareishard.com/blog/har-12-spec/",children:"HTTP Archive"})," (a.k.a. HAR) when an action is performed on the page."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ruby",children:"def retrieve_status_code\n  @proxy.new_har\n  yield\n  @proxy.har.entries.first.response.status\nend\n"})}),"\n",(0,n.jsx)(r.p,{children:"Now we're ready to wire up our test."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ruby",children:"run do\n  status_code = retrieve_status_code do\n    @driver.get 'http://the-internet.herokuapp.com/status_codes/404'\n  end\n\n  expect(status_code).to eql 404\nend\n"})}),"\n",(0,n.jsxs)(r.p,{children:["When visiting the page we are passing the Selenium command to the ",(0,n.jsx)(r.code,{children:"retrieve_status_code"})," method which returns the HTTP response code. We store this in a ",(0,n.jsx)(r.code,{children:"status_code"})," variable and use it to check that the response code is what we expect (",(0,n.jsx)(r.code,{children:"404"}),")."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," If you get an error when running your test, be sure to append ",(0,n.jsx)(r.code,{children:"log: true"})," when creating an instance of ",(0,n.jsx)(r.code,{children:"Browsermob::Proxy::Server"}),"."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ruby",children:"  server = BrowserMob::Proxy::Server.new(\n    File.join(Dir.pwd, 'browsermob-proxy-2.0.0/bin/browsermob-proxy'), log: true)\n"})}),"\n",(0,n.jsx)(r.p,{children:"Now when you run your test, you will see more detailed information as to why the server was unable to start."}),"\n",(0,n.jsx)(r.h2,{id:"expected-behavior",children:"Expected Behavior"}),"\n",(0,n.jsxs)(r.p,{children:["If you save this file and run it (e.g., ",(0,n.jsx)(r.code,{children:"ruby status_codes.rb"})," from the command-line) here is what will happen:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"Proxy server starts"}),"\n",(0,n.jsx)(r.li,{children:"Proxy server session created"}),"\n",(0,n.jsx)(r.li,{children:"Browser opens"}),"\n",(0,n.jsx)(r.li,{children:"Visit the URL"}),"\n",(0,n.jsx)(r.li,{children:"Retrieve the HTTP Status Code from loading the page"}),"\n",(0,n.jsx)(r.li,{children:"Check that the status code is what was expected"}),"\n",(0,n.jsx)(r.li,{children:"Browser closes"}),"\n",(0,n.jsx)(r.li,{children:"Proxy session closes"}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsxs)(r.p,{children:["This tip was inspired by ",(0,n.jsx)(r.a,{href:"https://twitter.com/jimevansmusic",children:"Jim Evans'"})," multi-part blog post series on doing the same thing in C# with Fiddler (",(0,n.jsx)(r.a,{href:"http://jimevansmusic.blogspot.com/2013/08/implementing-webdriver-http-status.html",children:"1"}),", ",(0,n.jsx)(r.a,{href:"http://jimevansmusic.blogspot.com/2013/08/implementing-http-status-codes-in.html",children:"2"}),", ",(0,n.jsx)(r.a,{href:"http://jimevansmusic.blogspot.com/2013/08/implementing-http-status-codes-in_17.html",children:"3"}),") which was in response to ",(0,n.jsx)(r.a,{href:"https://code.google.com/p/selenium/issues/detail?id=141",children:"Selenium Issue 141"}),". Thanks, Jim!"]}),"\n",(0,n.jsx)(r.p,{children:"Happy Testing!"})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>a});var n=t(96540);const s={},o=n.createContext(s);function i(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);